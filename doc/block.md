# block
1. block row 是一行多列，它可以做成一行一列的形式，并且是结构化的,这样就相当于是列存储了.
2. block row 的data 每个record，有头，如果一列的形式，可以省去这个节构, 更加快速的存储查询.
3. block row 目前是非结构化的，非定长，改完可以用定长的，更快索引。
4. sindex 一直是对每一条数据都索引，如果是定长的，不用每条都索引，只索引一个block可能就可以了。
5. 这样block row 就能支持单列存储了.
6. block 需要支持，多行多列存储，多行单列存储.
7. 目前一个record是N行, 而在时序排序的数据库里，一个record可能是单行，这个需要一个标记


## graph

record 可以是非结构化的，也可以是结构化的，
结构化的数据，它是一个M*N的矩阵，
可以按行一条一条写下去.
也可以按列一条一条写下去,按列本质上是把record拆成各个列分别写入blockid.

record 由于它是M条它可把这M条当成M个记录写进去.也可以把这M条记录当成一条record写入进去.
甚至还可以做个基于时间的,把M条当成一条记录写到数据库，给它记个时间点，每5分钟写入一条或者任意时间写入，开始归并。
归并出最新的快照，就是最新的数据，类似sql能看到的最大的view表。

M*N 应该也有一个id来对应。而每一条数据应该也有一条.

而如果一直看很多个时间点的数据，它就是时序数据库，可以做forcasting.
以上可以实现，logdb, perfdb, veritca 的存储结构

### 文档
record 一共有M条数据，每一条数据，都会生成一个id. 生成的doc id. 
而record[i]中每个分词，则用分词id, 每个分词有自己的block id, 它里面按时间从前到后
列着每个doc id. 这样方便按分词去查询id. 分词block 记录了最新的dock id和最旧的doc id
所在的block id. 这样方便从两头来查询id. 这看起来就像是一个列式的存储.
以上就可以实现lucense的存储引擎的内容

### 图数据库
图数据库存储分为点和边，点可以通过id来读取，而边也可以通过边id来读取，边可以简化成起点+边读取。这也是个id.
而当一个点包含的边太多的时候，可以使用分布式btree，把多个边合成一个v,做kv存储。
所以图的key 是个关键点，它由用户自己生成的id.而不是block_id + record_id的生成方式.



